/*
What this file is:
Robust adapter that scans a "Figma Tokens"-style export (or similar nested JSON)
and converts it into the canonical export schema expected by scripts/figma-sync.js.

Who should edit it:
Tooling Engineer or Token Owner who maintains Figma export adapters.

When to update (example):
Update if plugin export shapes change or the canonical schema evolves.

Who must approve changes:
Token Owner & Engineering Lead.

Usage:
  node scripts/adapters/figma-tokens-to-canonical.js --input ./figma/figma-export.json --output ./figma/canonical-export.json

Notes:
 - This adapter walks the entire JSON tree and collects objects that contain a 'value' or a 'type' property.
 - It normalizes token names into dot.path form and strips common top-level containers like 'global'.
 - It also splits numeric-hyphen segments like '16-regular' into '16.regular' to better match canonical naming.
*/

const fs = require('fs');
const path = require('path');

function usage() {
  console.log(
    'Usage: node scripts/adapters/figma-tokens-to-canonical.js --input <plugin-export.json> [--output <canonical.json>]'
  );
  process.exit(2);
}

const argv = process.argv.slice(2);
let input = null;
let output = path.resolve(process.cwd(), 'figma', 'canonical-export.json');

for (let i = 0; i < argv.length; i++) {
  if (argv[i] === '--input' && argv[i + 1]) {
    input = path.resolve(process.cwd(), argv[++i]);
  } else if (argv[i] === '--output' && argv[i + 1]) {
    output = path.resolve(process.cwd(), argv[++i]);
  } else {
    usage();
  }
}
if (!input) usage();

function readJson(p) {
  try {
    return JSON.parse(fs.readFileSync(p, 'utf8'));
  } catch (e) {
    console.error('Failed to read/parse', p, e && e.message);
    process.exit(1);
  }
}

function writeJson(p, obj) {
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, JSON.stringify(obj, null, 2) + '\n', 'utf8');
  console.log('Wrote canonical export to', p);
}

let tokenCounter = 0;

// Build a safe name from a path array, fallback to provided name or autogenerated index
function buildNameFromPath(pathArr, entry, idxFallback) {
  const cleaned = pathArr.map((p) => String(p).trim()).filter(Boolean);
  if (cleaned.length) return cleaned.join('/');
  if (entry && typeof entry.name === 'string') return entry.name;
  return `unnamed-token-${idxFallback}`;
}

// Normalize and canonicalize a dotPath:
// - convert slashes/spaces to dots
// - strip common top-level containers like 'global'
// - split segments like "16-regular" -> ["16","regular"]
function canonicalizeDotPath(rawNameOrDotPath) {
  if (!rawNameOrDotPath) return null;
  // if input already uses dots vs slashes, normalize both to array of segments
  // Use RegExp constructor to avoid unnecessary-escape lint rules for forward slash in literal
  let segments = String(rawNameOrDotPath)
    .trim()
    .replace(/^\.+|\.+$/g, '')
    .split(new RegExp('[/.]+'));

  // remove common container roots if present
  const containers = new Set(['global', 'tokens', 'properties', 'values', 'dictionary', 'styles']);
  if (segments.length > 1 && containers.has(segments[0].toLowerCase())) {
    segments = segments.slice(1);
  }

  // expand numeric-hyphen segments like "16-regular" -> ["16","regular"]
  const expanded = [];
  for (const seg of segments) {
    const m = String(seg).match(/^(\d+)-(.+)$/);
    if (m) {
      expanded.push(m[1]);
      // split further if the remainder contains separators; place hyphen first in class to avoid escapes
      expanded.push(...m[2].split(/[-_.\s]+/).filter(Boolean));
    } else {
      // also split remaining hyphens/underscores into subtokens but keep words together
      expanded.push(
        ...String(seg)
          .split(/[-_.\s]+/)
          .filter(Boolean)
      );
    }
  }

  // sanitize: lowercase, replace spaces, remove empty
  const cleaned = expanded
    .map((s) => String(s).trim())
    .filter(Boolean)
    .map((s) => s.toLowerCase());

  return cleaned.join('.');
}

function inferTypeFromValue(val) {
  if (typeof val === 'string') {
    const s = val.trim();
    if (/^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/.test(s)) return 'color';
    if (/\d+(px|rem|em|%)$/.test(s)) return 'spacing';
  }
  if (typeof val === 'number') return 'number';
  if (typeof val === 'object') return 'object';
  return null;
}

// The main walker: traverse entire tree; when an object with value/type is encountered, collect it
function walkAndCollect(node, ancestry = [], collector = []) {
  if (node === null || node === undefined) return;

  // If array: iterate with index
  if (Array.isArray(node)) {
    for (let i = 0; i < node.length; i++) {
      walkAndCollect(node[i], ancestry.concat([String(i)]), collector);
    }
    return;
  }

  // If primitive: nothing to do at top level (primitives are handled when nested under named keys by parent)
  if (typeof node !== 'object') return;

  // If object and looks like a token leaf (has 'value' or 'type'), collect it
  const hasValueKey = Object.prototype.hasOwnProperty.call(node, 'value');
  const hasTypeKey = Object.prototype.hasOwnProperty.call(node, 'type');

  if (hasValueKey || hasTypeKey) {
    tokenCounter++;
    const idxFallback = tokenCounter;
    const name = buildNameFromPath(ancestry, node, idxFallback);
    const rawDot = node.dotPath || name;
    const dotPath = canonicalizeDotPath(rawDot);

    // determine value
    let value =
      node.value !== undefined ? node.value : node.default !== undefined ? node.default : null;
    if ((value === null || value === undefined) && node.rawValue !== undefined)
      value = node.rawValue;
    if ((value === null || value === undefined) && node.val !== undefined) value = node.val;

    const type = node.type || inferTypeFromValue(value) || null;

    const token = {
      name,
      dotPath,
      type,
      value,
      description: node.description || node.comment || null,
      meta: Object.assign({}, node.meta || {}, { raw: node }),
    };
    collector.push(token);

    // Continue walking inside node to catch nested tokens too (rare but safe)
    for (const k of Object.keys(node)) {
      walkAndCollect(node[k], ancestry.concat([k]), collector);
    }
    return;
  }

  // Otherwise, traverse child keys
  for (const key of Object.keys(node)) {
    walkAndCollect(node[key], ancestry.concat([key]), collector);
  }
}

// Main
(function main() {
  const inJson = readJson(input);

  const collector = [];
  walkAndCollect(inJson, [], collector);

  // Filter tokens that have both a dotPath and a non-null value
  const filtered = collector.filter(
    (t) => t.dotPath && t.dotPath.trim() && t.value !== null && t.value !== undefined
  );

  const canonical = {
    schemaVersion: '1.0',
    exportedAt: new Date().toISOString(),
    source: { plugin: 'figma-tokens-adapter' },
    tokens: filtered,
  };

  writeJson(output, canonical);

  // Log summary and a few example token names for debugging
  console.log(`Adapter: scanned input and found ${collector.length} candidate token(s).`);
  console.log(`Adapter: filtered and produced ${filtered.length} token(s).`);
  if (filtered.length > 0) {
    console.log(
      'Adapter: examples:',
      filtered
        .slice(0, 12)
        .map((t) => t.dotPath)
        .join(', ')
    );
  } else {
    // print top-level keys to help debug why nothing was found
    console.log(
      'Adapter: no tokens produced. Top-level keys of input were:',
      Object.keys(inJson).slice(0, 20).join(', ') || '(none)'
    );
    try {
      const preview = JSON.stringify(inJson, null, 2);
      console.log('Adapter: small input preview (trimmed):', preview.slice(0, 2000));
    } catch (e) {
      /* ignore */
    }
  }
})();
